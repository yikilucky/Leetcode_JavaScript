## 剑指 Offer 62. 圆圈中最后剩下的数字

### 1. 暴力解法

要只剩最后一个数字需要循环n-1轮，每一轮都要找到第m个数字并删除，时间复杂度是`O(mn)`

### 2. 动态规划，利用约瑟夫环

输入n,m，记此约瑟夫环问题为【n,m问题】，该问题的解是最终留下数字在个数为n的轮次中的下标

```dart
最后只剩下一个元素，假设这个最后存活的元素为 num, 这个元素最终的下标一定是0 （因为最后只剩这一个元素），
所以如果我们可以推出上一轮次中这个num的下标，然后根据上一轮num的下标推断出上上一轮num的下标，
直到推断出元素个数为n的那一轮num的下标，那我们就可以根据这个下标获取到最终的元素了。推断过程如下：

首先最后一轮中num的下标一定是0， 这个是已知的。
那上一轮是有两个元素，此轮次中 num 的下标为 (0 + m)%n = (0+3)%2 = 1; 说明这一轮删除之前num的下标为1；
再上一轮应该有3个元素，此轮次中 num 的下标为 (1+3)%3 = 1；说明这一轮某元素被删除之前num的下标为1；
再上一轮应该有4个元素，此轮次中 num 的下标为 (1+3)%4 = 0；说明这一轮某元素被删除之前num的下标为0；
再上一轮应该有5个元素，此轮次中 num 的下标为 (0+3)%5 = 3；说明这一轮某元素被删除之前num的下标为3；
....

因为我们要删除的序列为0~n-1, 所以求得下标其实就是求得最终的结果。比如当n为5的时候，num的初始下标为3，所以num就是3，也就是说从0~n-1的序列中，经过n-1轮的淘汰，3这个元素最终存活下来了，也是最终的结果。

总结一下推导公式：dp[i]=(dp[i-1] + m) % i
```

`dp[i]`表示在个数为`i`的轮次中，最终留下数字的下标

由于`dp[i]`只由`dp[i-1]`推导而来，所以可以用变量`idx`存储上一个状态

```javascript
/**
 * @param {number} n
 * @param {number} m
 * @return {number}
 */
var lastRemaining = function(n, m) {
    let idx=0;
    for(let i=2;i<=n;i++){
        idx=(idx+m)%i
    }
    return idx;
};
```

时间复杂度是`O(n)`