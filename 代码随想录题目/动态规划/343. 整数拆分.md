## 动态规划

动态规划五部曲：

* 确定dp数组以及下标的含义：dp[i]：拆分数字i，得到的最大乘积是dp[i]
* 确定递推公式：对于整数i，从j=1开始来拆分i，终止条件是j<i-1(j=i-1的情况和j=1重复了，而且j=i-1，根据递推公式就会出现dp[1]，dp[1]没意义)。**但其实只需要遍历到`i/2`就行了(解释在最后）。**每次拆分都要比较`j*(i-j)`和`j*dp[i-j]`的大小，前者相当于把i拆成2个数，后者相当于把i拆成2个以上的数。最终递推公式：`dp[i]=Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]))`
* 数组初始化：新建dp数组，把元素全初始化为0；dp[0]和dp[1]没意义，不用额外初始化；需要初始化dp[2]，因为dp[2]用递推公式是基于dp[1]的，而dp[1]没意义，所以不能用递推公式来得到dp[2]，应该直接初始化它，然后从dp[3]开始用递推公式
* 确定遍历顺序：根据递推公式，确定dp[i]首先要知道dp[i-j]，所以从前往后遍历
* 举例推导dp数组

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var integerBreak = function(n) {
    let dp=new Array(n+1).fill(0);
    dp[2]=1;
    for(let i=3;i<=n;i++){
        for(let j=1;j<i-1;j++){
            dp[i]=Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));
        }
    }
    return dp[n];
};
```

j只要遍历到`i/2`的解释：拆分一个数n，使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的。本题中m大于等于2，也就是最差也应该是拆成两个相同的字数可能是最大值

## 贪心算法

这道题也可以用贪心算法，但需要用到数学结论